# **C- Compiler** 
## CIS*4650 - Compilers (Implementation Project)
*by: Nic Baker & Garrett Holmes*
***
**NOTE*: All CUP & Jflex code is adapted from example provided by **Prof. Fei Song** for this project (C1-Package), which includes a compiler for the tiny programming language. The `Main.java` & `Scanner.java` files are unchanged from his example.
***
### *Overview*
This project includes an implementation of a compiler for the C- simplified programming  language. The compiler is written in Java using the JFlex scanner generator and the CUP parser generator. The compiler will produce assembly language output for the TM simulator, where the compiled assembly language programs can be executed.

The compiler will work in steps that can be completed via command line input.

- **Options:** Flags - output a file with the same name as the source with the specified extension.
    - [x] -a: Perform a syntactic analysis and output an abstract syntax tree (.abs)
    - [x] -s: Perform type checking and output symbol tables (.sym)
    - [x] -c: Compile and output TM assembly language code (.tm) which can be run using `TMSimulator/tm.c`

### *Requirements*:
- [openJDK version 11+](https://openjdk.org/)
- [Jflex](https://jflex.de/)
- [CUP](http://www2.cs.tum.edu/projects/cup/)
- [TMSimulator](included)

### *Compilation*
- Adjust the variables in the Makefile as specified to point to your CUP & Jflex Installs.
- `make`/`make all` : build all targets
- `make clean` : remove all generated files (parser.java, scanner.java, *.class, etc.)

### *Running*:
- `java -cp /usr/share/java/cup.jar:. Main cmFiles/[#].cm [flags]` : Run main Abstract Syntax Tree program, output printed to stdout.
    - `[#].cm`: 1 - 5 are the available .cm files. 
    - [flags]: *See, '**Options**' above.
- Running `.tm` files:
    - `cd TMSimulator`
    - `make`
    - `./tm` (Note: may have to make the file executable)
    - Run steps as described in `/TMSimulator/Reame`

***

## **Checkpoint 3**

### *Overview & Structure*
Checkpoint 3 completes our implementation of the C- compiler by generating machine code for the TM (Tiny Machne) Simulator. We generate our code using the `CodeGeneration.java` class, which traverses the syntax tree generated by `cm.cup` in post-order and iteratively builds TMSimulator code based on the tree structure. The machine code is written to a `.tm` file which can later be run as input to the `TMSimulator/tm.c` program. The code generation program is implemented through a command line parameter/flag `-c` used when running `Main.java` in the command line.


### *Design*

**Scanner**
The scanner, which is generated by Jflex using specifications in the `cm.flex` file, reads through the input text and matches input phrases with regular expressions representing an output token. The tokens are returned as cup-specific 'symbol' objects, which contain information about the token name, text, and in some cases, row and column. `Scanner.java` includes code that runs the 'Lexer' class generated by Jflex. If run on it's own, the scanner will output the tokens scanned by the jflex-generated files.

**Parser**
The CUP parser generator is used to create a token parser based on specifications in the `cm.cup` file. The specification file interfaces with the Jflex scanner through the %cup compatibility option specified in the `cm.flex` file, which allows the parser to use the tokens generated by the Jflex scanner to parse the input code according to the grammar rules specified in `cm.cup`. The grammar rules define the structure of the abstract syntax tree (AST) for the input C- program, and is implemented using the Java classes defined in the `/absyn` directory, which classes represent variables, expressions, variable and function definitions, variable declarations, and various lists. For each grammar definition, java code is run which specifies the 'result' of each production, which may be other non-terminals or terminals (members of `/absyn`). The generated parser is run as an instance of the Absyn class in Main.java, which parses the input code and outputs the AST using an instance of ShowTreeVisitor. The parser allows us to check for syntax errors such as missing semicolons or mis-used statements. Some errors can be recovered from here, others are considered fatal and will stop compilation.

**Symbol Table**
The symbol table is implemented by a HashMap which uses Strings as keys representing variable or function names, and an ArrayList acting as a stack. The most recent data type in the list is consistent for all variables in the given scope.
All nodes that are the children on a single parent node are within the scope of that parent node. Thus, any variable definitions within that scope will be accessible within that scope and also subsequent scopes. If a symbol is accessed outside of its scope (ie. as the child of an adjacent/separate node), the symbol table will report an error.
When the symbol table has visited all of the children of a node, it will remove the entries in the stack for the latest scope. This allows us to check for semantic errors such as undefined or mis-used variables, or other errors related to type definitions. If an error is found in the semantic analyzation step, compilation will stop.

**TM Compiler**
Our compiler implementation skips intermediate code generation and generates machine code straight from the abstract syntax tree, this requires some . In our implementation, the syntax tree is traversed in post-order using a similar traversal method to the `ShowTreeVisitor.java` & `SemanticAnalyzer.java`, where we recursively traverse to the bottom left-hand side of the tree, then operate upwards from there.
For each node of the AST, we generate code using 'emit[]' functions, which create TM machine code strings based on parameters such as memory location, register, etc. The code strings are added to a stack which is later written to a `.tm` file of the same name as the input `.cm` file.


### *Assumptions & Limitations*
- The input cm filename must be of the format `dir/name.type` or `name.type`. Special cases beyond this are not handeled.
- The compiler will output any created files (ie. `.abs`, `.sym`) in the same directory as `Main.java` regardless of the path of the input file.
- Running `make clean` will also clear any generated `.abs`, `.tm` and `.sym` files.
- All sample files provided (with errors) will fail to compile, and all sample files provided that have no indicated errors will compile successfully.
- We cannot guaruntee that the compiled `.tm` file will run as expected when put through the TMSimulator (`tm.c`), the machine code is output and readable in the generated `.tm` files, but may contain errors in machine code that fail to run.
- Some syntax errors (such as irresponsible placement of expressiokns before definitions) will report seemingly unrelated error messages occasionally.

### *Contributions*:
- **Nic**:
    - Absyn / Traveral code refactoring.
    - Definition of constant TM functions, IN/OUT functions.
    - Tree traversal & code translation
    - emit functions 
    - Prelude, I/O, Finale

- **Garrett**: 
    - Documentation.
    - Additional features from checkpoints 1 & 2.
    - Error Checking, additional traversal & machine code implementation.

#### **Lessons**
This project overall enabled us to gain a significantly deeper understanding of compiler implementations. Through building an abstract syntax tree and a symbol table we were able to closely analyze not just the structure of a standard compiler, but also the specifics of code and how it can be translated procedurally to interact with hardware. These experiences can lead to a better udnerstanding of code structures and hopefully an improved ability to write efficient and optimized code.

This checkpoint in particular required revisiting our previous experiences with machine code & machine code structures. We were required to translate our knowledge of the M68k architecture to the simplified, but similar, simulation of the TM simulator.
We gained further experience following a modular design structure, where tree traversal functions called individual TM code generation functions that were more specific to each node type.

We wrote a number of new function for debugging purposes & for accessing data contained in absyn classes (such as VarDecList) for the purpose of semantic error checking and variable access.

### *Testing Overview*

There are 10 .cm files which contain the same sample programs provided in the given C- specification (bool, fac, gcd, rec, sort) - which are also included on their own, only modified to contain numerous semantic errors (no more than 3) that are reported by the semantic analyzer and (generally) recovered from. Ther are also 5 original C- programs. The errors in the C- files are described in the comments at the top of each file. 

We used these files to test the handling of specific semantic errors as the handling was written.
Some files, specifically the simpler C- programs without errors, were modified occasionally during development to test specific errors in a clean environment, which were then added to other test files permanently.

- **Example C- Programs**
    - 1.cm - 3.cm: Small programs, compile without error.
    - 4.cm - 8.cm: Modified versions of sample files, contain up to 3 errors (semantic, syntax, etc.)
    - 9.cm - 0.cm: Additional cm files with various errors.